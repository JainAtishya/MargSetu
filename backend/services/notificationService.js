const mongoose = require('mongoose');
const emailService = require('../services/emailService');

const notificationSchema = new mongoose.Schema({
  type: {
    type: String,
    enum: [
      'route_deviation',
      'speed_violation',
      'geofence_entry',
      'geofence_exit',
      'emergency_alert',
      'maintenance_reminder',
      'passenger_alert',
      'driver_shift',
      'fuel_low',
      'breakdown',
      'arrival_notification',
      'delay_alert',
      'capacity_alert',
      'security_alert'
    ],
    required: true
  },
  
  priority: {
    type: String,
    enum: ['low', 'medium', 'high', 'critical'],
    default: 'medium'
  },
  
  title: {
    type: String,
    required: true,
    maxlength: 100
  },
  
  message: {
    type: String,
    required: true,
    maxlength: 500
  },
  
  recipients: [{
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    userType: {
      type: String,
      enum: ['passenger', 'driver', 'authority', 'admin']
    },
    contactMethod: {
      type: String,
      enum: ['push', 'email', 'sms', 'in_app'],
      default: 'push'
    },
    contactValue: String, // email address, phone number, or device token
    deliveryStatus: {
      type: String,
      enum: ['pending', 'sent', 'delivered', 'failed', 'read'],
      default: 'pending'
    },
    sentAt: Date,
    deliveredAt: Date,
    readAt: Date,
    errorMessage: String
  }],
  
  relatedEntity: {
    entityType: {
      type: String,
      enum: ['bus', 'route', 'driver', 'passenger', 'geofence', 'location']
    },
    entityId: mongoose.Schema.Types.Mixed, // Can be ObjectId or string
    entityData: mongoose.Schema.Types.Mixed // Additional context data
  },
  
  location: {
    type: {
      type: String,
      enum: ['Point'],
      default: 'Point'
    },
    coordinates: {
      type: [Number], // [longitude, latitude]
      index: '2dsphere'
    }
  },
  
  metadata: {
    busId: String,
    routeId: String,
    driverId: String,
    severity: String,
    category: String,
    tags: [String],
    autoGenerated: {
      type: Boolean,
      default: true
    },
    requiresAction: {
      type: Boolean,
      default: false
    },
    actionTaken: {
      type: Boolean,
      default: false
    },
    actionDetails: String
  },
  
  deliveryConfig: {
    immediate: {
      type: Boolean,
      default: true
    },
    retryAttempts: {
      type: Number,
      default: 3,
      max: 5
    },
    retryInterval: {
      type: Number,
      default: 300 // seconds
    },
    expiresAt: Date,
    batchable: {
      type: Boolean,
      default: false
    }
  },
  
  isActive: {
    type: Boolean,
    default: true
  },
  
  resolvedAt: Date,
  resolvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }
}, {
  timestamps: true
});

// Indexes for performance
notificationSchema.index({ type: 1, priority: 1 });
notificationSchema.index({ 'recipients.userId': 1, createdAt: -1 });
notificationSchema.index({ 'metadata.busId': 1, createdAt: -1 });
notificationSchema.index({ 'metadata.routeId': 1, createdAt: -1 });
notificationSchema.index({ createdAt: -1 });
notificationSchema.index({ 'deliveryConfig.expiresAt': 1 }, { expireAfterSeconds: 0 });
notificationSchema.index({ location: '2dsphere' });

// Instance methods
notificationSchema.methods.markAsRead = function(userId) {
  const recipient = this.recipients.find(r => r.userId.toString() === userId.toString());
  if (recipient) {
    recipient.deliveryStatus = 'read';
    recipient.readAt = new Date();
  }
  return this.save();
};

notificationSchema.methods.updateDeliveryStatus = function(userId, status, errorMessage = null) {
  const recipient = this.recipients.find(r => r.userId.toString() === userId.toString());
  if (recipient) {
    recipient.deliveryStatus = status;
    if (status === 'sent') {
      recipient.sentAt = new Date();
    } else if (status === 'delivered') {
      recipient.deliveredAt = new Date();
    } else if (status === 'failed') {
      recipient.errorMessage = errorMessage;
    }
  }
  return this.save();
};

notificationSchema.methods.shouldRetry = function() {
  if (!this.deliveryConfig.immediate) return false;
  
  const failedRecipients = this.recipients.filter(r => r.deliveryStatus === 'failed');
  const now = new Date();
  
  return failedRecipients.some(recipient => {
    const retryCount = recipient.retryCount || 0;
    const lastAttempt = recipient.sentAt || this.createdAt;
    const timeSinceLastAttempt = (now - lastAttempt) / 1000; // seconds
    
    return retryCount < this.deliveryConfig.retryAttempts && 
           timeSinceLastAttempt >= this.deliveryConfig.retryInterval;
  });
};

// Static methods
notificationSchema.statics.createNotification = async function(notificationData) {
  try {
    const notification = new this(notificationData);
    await notification.save();
    
    // Trigger immediate delivery if configured
    if (notification.deliveryConfig.immediate) {
      await NotificationService.deliverNotification(notification);
    }
    
    return notification;
  } catch (error) {
    console.error('Error creating notification:', error);
    throw error;
  }
};

notificationSchema.statics.createBulkNotifications = async function(notificationsData) {
  try {
    const notifications = await this.insertMany(notificationsData);
    
    // Process immediate deliveries
    const immediateNotifications = notifications.filter(n => n.deliveryConfig.immediate);
    
    for (const notification of immediateNotifications) {
      NotificationService.deliverNotification(notification).catch(error => {
        console.error('Error delivering bulk notification:', error);
      });
    }
    
    return notifications;
  } catch (error) {
    console.error('Error creating bulk notifications:', error);
    throw error;
  }
};

notificationSchema.statics.getUnreadCount = function(userId, userType = null) {
  const query = {
    'recipients.userId': userId,
    'recipients.deliveryStatus': { $ne: 'read' },
    isActive: true
  };
  
  if (userType) {
    query['recipients.userType'] = userType;
  }
  
  return this.countDocuments(query);
};

notificationSchema.statics.getUserNotifications = function(userId, options = {}) {
  const {
    page = 1,
    limit = 20,
    types = null,
    priority = null,
    unreadOnly = false,
    startDate = null,
    endDate = null
  } = options;
  
  const query = {
    'recipients.userId': userId,
    isActive: true
  };
  
  if (types && types.length > 0) {
    query.type = { $in: types };
  }
  
  if (priority) {
    query.priority = priority;
  }
  
  if (unreadOnly) {
    query['recipients.deliveryStatus'] = { $ne: 'read' };
  }
  
  if (startDate || endDate) {
    query.createdAt = {};
    if (startDate) query.createdAt.$gte = new Date(startDate);
    if (endDate) query.createdAt.$lte = new Date(endDate);
  }
  
  return this.find(query)
    .sort({ createdAt: -1 })
    .skip((page - 1) * limit)
    .limit(limit)
    .populate('relatedEntity.entityId')
    .populate('recipients.userId', 'name email phone');
};

notificationSchema.statics.getSystemAnalytics = function(days = 7) {
  const fromDate = new Date();
  fromDate.setDate(fromDate.getDate() - days);
  
  return this.aggregate([
    {
      $match: {
        createdAt: { $gte: fromDate }
      }
    },
    {
      $group: {
        _id: {
          type: '$type',
          priority: '$priority',
          date: { $dateToString: { format: '%Y-%m-%d', date: '$createdAt' } }
        },
        count: { $sum: 1 },
        avgDeliveryTime: {
          $avg: {
            $cond: {
              if: { $ne: ['$recipients.deliveredAt', null] },
              then: { 
                $subtract: ['$recipients.deliveredAt', '$createdAt'] 
              },
              else: null
            }
          }
        }
      }
    },
    {
      $group: {
        _id: {
          type: '$_id.type',
          priority: '$_id.priority'
        },
        totalCount: { $sum: '$count' },
        dailyBreakdown: {
          $push: {
            date: '$_id.date',
            count: '$count',
            avgDeliveryTime: '$avgDeliveryTime'
          }
        }
      }
    },
    {
      $sort: { totalCount: -1 }
    }
  ]);
};

// Notification Service Class
class NotificationService {
  static async deliverNotification(notification) {
    try {
      for (const recipient of notification.recipients) {
        await this.deliverToRecipient(notification, recipient);
      }
    } catch (error) {
      console.error('Error delivering notification:', error);
    }
  }
  
  static async deliverToRecipient(notification, recipient) {
    try {
      const { contactMethod, contactValue } = recipient;
      
      switch (contactMethod) {
        case 'email':
          await this.sendEmail(notification, recipient);
          break;
        case 'sms':
          await this.sendSMS(notification, recipient);
          break;
        case 'push':
          await this.sendPushNotification(notification, recipient);
          break;
        case 'in_app':
          await this.sendInAppNotification(notification, recipient);
          break;
        default:
          throw new Error(`Unsupported contact method: ${contactMethod}`);
      }
      
      await notification.updateDeliveryStatus(recipient.userId, 'sent');
      
    } catch (error) {
      console.error(`Error delivering to recipient ${recipient.userId}:`, error);
      await notification.updateDeliveryStatus(recipient.userId, 'failed', error.message);
    }
  }
  
  static async sendEmail(notification, recipient) {
    const emailTemplate = this.getEmailTemplate(notification);
    
    await emailService.sendEmail({
      to: recipient.contactValue,
      subject: notification.title,
      html: emailTemplate,
      priority: notification.priority
    });
  }
  
  static async sendSMS(notification, recipient) {
    // Integrate with SMS service (Twilio, AWS SNS, etc.)
    console.log(`SMS to ${recipient.contactValue}: ${notification.message}`);
    // Placeholder for SMS implementation
  }
  
  static async sendPushNotification(notification, recipient) {
    // Integrate with push notification service (Firebase, OneSignal, etc.)
    console.log(`Push to ${recipient.contactValue}: ${notification.title}`);
    // Placeholder for push notification implementation
  }
  
  static async sendInAppNotification(notification, recipient) {
    // Store in-app notification in database or emit via WebSocket
    const io = global.io; // Assuming Socket.IO is available globally
    if (io) {
      io.to(`user_${recipient.userId}`).emit('notification', {
        id: notification._id,
        type: notification.type,
        title: notification.title,
        message: notification.message,
        priority: notification.priority,
        timestamp: notification.createdAt
      });
    }
  }
  
  static getEmailTemplate(notification) {
    const priorityColors = {
      low: '#28a745',
      medium: '#ffc107',
      high: '#fd7e14',
      critical: '#dc3545'
    };
    
    const color = priorityColors[notification.priority] || '#6c757d';
    
    return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background-color: ${color}; color: white; padding: 20px; text-align: center;">
          <h1 style="margin: 0;">${notification.title}</h1>
          <span style="background-color: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; font-size: 12px; text-transform: uppercase;">
            ${notification.priority} Priority
          </span>
        </div>
        <div style="padding: 20px; background-color: #f8f9fa;">
          <p style="font-size: 16px; line-height: 1.5; margin-bottom: 20px;">
            ${notification.message}
          </p>
          
          ${notification.metadata.busId ? `<p><strong>Bus:</strong> ${notification.metadata.busId}</p>` : ''}
          ${notification.metadata.routeId ? `<p><strong>Route:</strong> ${notification.metadata.routeId}</p>` : ''}
          ${notification.location ? `<p><strong>Location:</strong> ${notification.location.coordinates[1]}, ${notification.location.coordinates[0]}</p>` : ''}
          
          <p style="font-size: 12px; color: #6c757d; margin-top: 20px;">
            Sent at: ${notification.createdAt.toLocaleString()}
          </p>
        </div>
        <div style="background-color: #e9ecef; padding: 15px; text-align: center; font-size: 12px; color: #6c757d;">
          MargSetu - Smart Bus Tracking System
        </div>
      </div>
    `;
  }
  
  // Alert creation helpers for GPS events
  static async createRouteDeviationAlert(busId, location, deviation) {
    return await mongoose.model('Notification').createNotification({
      type: 'route_deviation',
      priority: deviation > 1000 ? 'high' : 'medium', // 1km threshold
      title: 'Bus Route Deviation Detected',
      message: `Bus ${busId} has deviated ${Math.round(deviation)}m from its planned route.`,
      recipients: await this.getRouteAuthorities(busId),
      relatedEntity: {
        entityType: 'bus',
        entityId: busId,
        entityData: { deviation, timestamp: new Date() }
      },
      location: {
        type: 'Point',
        coordinates: [location.longitude, location.latitude]
      },
      metadata: {
        busId,
        severity: deviation > 1000 ? 'high' : 'medium',
        category: 'route_monitoring',
        autoGenerated: true,
        requiresAction: deviation > 500
      }
    });
  }
  
  static async createSpeedViolationAlert(busId, location, speed, speedLimit) {
    return await mongoose.model('Notification').createNotification({
      type: 'speed_violation',
      priority: speed > speedLimit * 1.5 ? 'critical' : 'high',
      title: 'Speed Limit Violation',
      message: `Bus ${busId} is traveling at ${speed} km/h in a ${speedLimit} km/h zone.`,
      recipients: await this.getDriverAndAuthorities(busId),
      relatedEntity: {
        entityType: 'bus',
        entityId: busId,
        entityData: { speed, speedLimit, violation: speed - speedLimit }
      },
      location: {
        type: 'Point',
        coordinates: [location.longitude, location.latitude]
      },
      metadata: {
        busId,
        severity: 'high',
        category: 'safety',
        autoGenerated: true,
        requiresAction: true
      }
    });
  }
  
  static async createGeofenceAlert(busId, geofence, eventType, dwellTime = null) {
    const message = eventType === 'entry' 
      ? `Bus ${busId} has entered ${geofence.name}`
      : `Bus ${busId} has exited ${geofence.name}${dwellTime ? ` after ${Math.round(dwellTime/60)} minutes` : ''}`;
    
    return await mongoose.model('Notification').createNotification({
      type: `geofence_${eventType}`,
      priority: geofence.metadata.priority || 'medium',
      title: `Geofence ${eventType.charAt(0).toUpperCase() + eventType.slice(1)}`,
      message,
      recipients: geofence.alertSettings.alertRecipients.length > 0 
        ? geofence.alertSettings.alertRecipients.map(r => ({
            contactMethod: r.method,
            contactValue: r.type
          }))
        : await this.getRouteAuthorities(busId),
      relatedEntity: {
        entityType: 'geofence',
        entityId: geofence._id,
        entityData: { eventType, dwellTime, busId }
      },
      metadata: {
        busId,
        category: 'geofencing',
        autoGenerated: true,
        requiresAction: false
      }
    });
  }
  
  static async getRouteAuthorities(busId) {
    // Get authorities responsible for the route of this bus
    const Bus = mongoose.model('Bus');
    const User = mongoose.model('User');
    
    const bus = await Bus.findOne({ busId }).populate('route');
    if (!bus || !bus.route) return [];
    
    const authorities = await User.find({
      role: 'authority',
      'assignedRoutes': bus.route._id
    });
    
    return authorities.map(auth => ({
      userId: auth._id,
      userType: 'authority',
      contactMethod: 'email',
      contactValue: auth.email
    }));
  }
  
  static async getDriverAndAuthorities(busId) {
    const Bus = mongoose.model('Bus');
    const User = mongoose.model('User');
    
    const bus = await Bus.findOne({ busId }).populate(['currentDriver', 'route']);
    if (!bus) return [];
    
    const recipients = [];
    
    // Add driver
    if (bus.currentDriver) {
      recipients.push({
        userId: bus.currentDriver._id,
        userType: 'driver',
        contactMethod: 'push',
        contactValue: bus.currentDriver.deviceToken
      });
    }
    
    // Add authorities
    if (bus.route) {
      const authorities = await User.find({
        role: 'authority',
        'assignedRoutes': bus.route._id
      });
      
      authorities.forEach(auth => {
        recipients.push({
          userId: auth._id,
          userType: 'authority',
          contactMethod: 'email',
          contactValue: auth.email
        });
      });
    }
    
    return recipients;
  }
}

module.exports = {
  Notification: mongoose.model('Notification', notificationSchema),
  NotificationService
};